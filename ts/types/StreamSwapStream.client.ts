/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, Timestamp, Uint64, UncheckedDenom, Schedule, InstantiateMsg, CreatePool, MsgCreateConcentratedPool, Coin, InstantiateMsg1, ExecuteMsg, Binary, QueryMsg, Decimal, AveragePriceResponse, LatestStreamedPriceResponse, Decimal256, Addr, PositionsResponse, PositionResponse, Params, Status, StreamResponse } from "./StreamSwapStream.types";
export interface StreamSwapStreamReadOnlyInterface {
  contractAddress: string;
  params: () => Promise<Params>;
  stream: () => Promise<StreamResponse>;
  position: ({
    owner
  }: {
    owner: string;
  }) => Promise<PositionResponse>;
  listPositions: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PositionsResponse>;
  averagePrice: () => Promise<AveragePriceResponse>;
  lastStreamedPrice: () => Promise<LatestStreamedPriceResponse>;
  threshold: () => Promise<Uint128>;
}
export class StreamSwapStreamQueryClient implements StreamSwapStreamReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.params = this.params.bind(this);
    this.stream = this.stream.bind(this);
    this.position = this.position.bind(this);
    this.listPositions = this.listPositions.bind(this);
    this.averagePrice = this.averagePrice.bind(this);
    this.lastStreamedPrice = this.lastStreamedPrice.bind(this);
    this.threshold = this.threshold.bind(this);
  }

  params = async (): Promise<Params> => {
    return this.client.queryContractSmart(this.contractAddress, {
      params: {}
    });
  };
  stream = async (): Promise<StreamResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      stream: {}
    });
  };
  position = async ({
    owner
  }: {
    owner: string;
  }): Promise<PositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position: {
        owner
      }
    });
  };
  listPositions = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PositionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_positions: {
        limit,
        start_after: startAfter
      }
    });
  };
  averagePrice = async (): Promise<AveragePriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      average_price: {}
    });
  };
  lastStreamedPrice = async (): Promise<LatestStreamedPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      last_streamed_price: {}
    });
  };
  threshold = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      threshold: {}
    });
  };
}
export interface StreamSwapStreamInterface extends StreamSwapStreamReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateStream: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOperator: ({
    newOperator
  }: {
    newOperator?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  subscribe: ({
    operator,
    operatorTarget
  }: {
    operator?: string;
    operatorTarget?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    cap,
    operatorTarget
  }: {
    cap?: Uint128;
    operatorTarget?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updatePosition: ({
    operatorTarget
  }: {
    operatorTarget?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  finalizeStream: ({
    newTreasury
  }: {
    newTreasury?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  exitStream: ({
    operatorTarget,
    salt
  }: {
    operatorTarget?: string;
    salt?: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pauseStream: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawPaused: ({
    cap,
    operatorTarget
  }: {
    cap?: Uint128;
    operatorTarget?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  exitCancelled: ({
    operatorTarget
  }: {
    operatorTarget?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  resumeStream: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  cancelStream: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  cancelStreamWithThreshold: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class StreamSwapStreamClient extends StreamSwapStreamQueryClient implements StreamSwapStreamInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateStream = this.updateStream.bind(this);
    this.updateOperator = this.updateOperator.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.updatePosition = this.updatePosition.bind(this);
    this.finalizeStream = this.finalizeStream.bind(this);
    this.exitStream = this.exitStream.bind(this);
    this.pauseStream = this.pauseStream.bind(this);
    this.withdrawPaused = this.withdrawPaused.bind(this);
    this.exitCancelled = this.exitCancelled.bind(this);
    this.resumeStream = this.resumeStream.bind(this);
    this.cancelStream = this.cancelStream.bind(this);
    this.cancelStreamWithThreshold = this.cancelStreamWithThreshold.bind(this);
  }

  updateStream = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      sync_stream: {}
    }, fee, memo, _funds);
  };
  updateOperator = async ({
    newOperator
  }: {
    newOperator?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_operator: {
        new_operator: newOperator
      }
    }, fee, memo, _funds);
  };
  subscribe = async ({
    operator,
    operatorTarget
  }: {
    operator?: string;
    operatorTarget?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      subscribe: {
        operator,
        operator_target: operatorTarget
      }
    }, fee, memo, _funds);
  };
  withdraw = async ({
    cap,
    operatorTarget
  }: {
    cap?: Uint128;
    operatorTarget?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        cap,
        operator_target: operatorTarget
      }
    }, fee, memo, _funds);
  };
  updatePosition = async ({
    operatorTarget
  }: {
    operatorTarget?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_position: {
        operator_target: operatorTarget
      }
    }, fee, memo, _funds);
  };
  finalizeStream = async ({
    newTreasury
  }: {
    newTreasury?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      finalize_stream: {
        new_treasury: newTreasury
      }
    }, fee, memo, _funds);
  };
  exitStream = async ({
    operatorTarget,
    salt
  }: {
    operatorTarget?: string;
    salt?: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      exit_stream: {
        operator_target: operatorTarget,
        salt
      }
    }, fee, memo, _funds);
  };
  pauseStream = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pause_stream: {}
    }, fee, memo, _funds);
  };
  withdrawPaused = async ({
    cap,
    operatorTarget
  }: {
    cap?: Uint128;
    operatorTarget?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_paused: {
        cap,
        operator_target: operatorTarget
      }
    }, fee, memo, _funds);
  };
  exitCancelled = async ({
    operatorTarget
  }: {
    operatorTarget?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      exit_cancelled: {
        operator_target: operatorTarget
      }
    }, fee, memo, _funds);
  };
  resumeStream = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      resume_stream: {}
    }, fee, memo, _funds);
  };
  cancelStream = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_stream: {}
    }, fee, memo, _funds);
  };
  cancelStreamWithThreshold = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_stream_with_threshold: {}
    }, fee, memo, _funds);
  };
}