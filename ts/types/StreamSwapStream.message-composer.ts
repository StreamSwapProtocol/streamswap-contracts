/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { MsgExecuteContractEncodeObject } from "@cosmjs/cosmwasm-stargate";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@cosmjs/encoding";
import { Uint128, Timestamp, Uint64, UncheckedDenom, Schedule, InstantiateMsg, CreatePool, MsgCreateConcentratedPool, Coin, InstantiateMsg1, ExecuteMsg, Binary, QueryMsg, Decimal, AveragePriceResponse, LatestStreamedPriceResponse, Decimal256, Addr, PositionsResponse, PositionResponse, Params, Status, StreamResponse } from "./StreamSwapStream.types";
export interface StreamSwapStreamMsg {
  contractAddress: string;
  sender: string;
  updateStream: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  updateOperator: ({
    newOperator
  }: {
    newOperator?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  subscribe: ({
    operator,
    operatorTarget
  }: {
    operator?: string;
    operatorTarget?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdraw: ({
    cap,
    operatorTarget
  }: {
    cap?: Uint128;
    operatorTarget?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  updatePosition: ({
    operatorTarget
  }: {
    operatorTarget?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  finalizeStream: ({
    newTreasury
  }: {
    newTreasury?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  exitStream: ({
    operatorTarget,
    salt
  }: {
    operatorTarget?: string;
    salt?: Binary;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  pauseStream: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdrawPaused: ({
    cap,
    operatorTarget
  }: {
    cap?: Uint128;
    operatorTarget?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  exitCancelled: ({
    operatorTarget
  }: {
    operatorTarget?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  resumeStream: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  cancelStream: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  cancelStreamWithThreshold: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
export class StreamSwapStreamMsgComposer implements StreamSwapStreamMsg {
  sender: string;
  contractAddress: string;

  constructor(sender: string, contractAddress: string) {
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateStream = this.updateStream.bind(this);
    this.updateOperator = this.updateOperator.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.updatePosition = this.updatePosition.bind(this);
    this.finalizeStream = this.finalizeStream.bind(this);
    this.exitStream = this.exitStream.bind(this);
    this.pauseStream = this.pauseStream.bind(this);
    this.withdrawPaused = this.withdrawPaused.bind(this);
    this.exitCancelled = this.exitCancelled.bind(this);
    this.resumeStream = this.resumeStream.bind(this);
    this.cancelStream = this.cancelStream.bind(this);
    this.cancelStreamWithThreshold = this.cancelStreamWithThreshold.bind(this);
  }

  updateStream = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          sync_stream: {}
        })),
        funds: _funds
      })
    };
  };
  updateOperator = ({
    newOperator
  }: {
    newOperator?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          update_operator: {
            new_operator: newOperator
          }
        })),
        funds: _funds
      })
    };
  };
  subscribe = ({
    operator,
    operatorTarget
  }: {
    operator?: string;
    operatorTarget?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          subscribe: {
            operator,
            operator_target: operatorTarget
          }
        })),
        funds: _funds
      })
    };
  };
  withdraw = ({
    cap,
    operatorTarget
  }: {
    cap?: Uint128;
    operatorTarget?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw: {
            cap,
            operator_target: operatorTarget
          }
        })),
        funds: _funds
      })
    };
  };
  updatePosition = ({
    operatorTarget
  }: {
    operatorTarget?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          update_position: {
            operator_target: operatorTarget
          }
        })),
        funds: _funds
      })
    };
  };
  finalizeStream = ({
    newTreasury
  }: {
    newTreasury?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          finalize_stream: {
            new_treasury: newTreasury
          }
        })),
        funds: _funds
      })
    };
  };
  exitStream = ({
    operatorTarget,
    salt
  }: {
    operatorTarget?: string;
    salt?: Binary;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          exit_stream: {
            operator_target: operatorTarget,
            salt
          }
        })),
        funds: _funds
      })
    };
  };
  pauseStream = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          pause_stream: {}
        })),
        funds: _funds
      })
    };
  };
  withdrawPaused = ({
    cap,
    operatorTarget
  }: {
    cap?: Uint128;
    operatorTarget?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw_paused: {
            cap,
            operator_target: operatorTarget
          }
        })),
        funds: _funds
      })
    };
  };
  exitCancelled = ({
    operatorTarget
  }: {
    operatorTarget?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          exit_cancelled: {
            operator_target: operatorTarget
          }
        })),
        funds: _funds
      })
    };
  };
  resumeStream = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          resume_stream: {}
        })),
        funds: _funds
      })
    };
  };
  cancelStream = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          cancel_stream: {}
        })),
        funds: _funds
      })
    };
  };
  cancelStreamWithThreshold = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          cancel_stream_with_threshold: {}
        })),
        funds: _funds
      })
    };
  };
}